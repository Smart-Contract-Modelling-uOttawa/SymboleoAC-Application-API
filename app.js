/*
 * Copyright IBM Corp. All Rights Reserved.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

'use strict';



// use this to set logging, must be set before the require('fabric-network');
process.env.HFC_LOGGING = '{"debug": "./debug.log"}';

const { Gateway, Wallets } = require('fabric-network');
const EventStrategies = require('fabric-network/lib/impl/event/defaulteventhandlerstrategies');
const FabricCAServices = require('fabric-ca-client');
const path = require('path');
const fs = require('fs');
const {publish} = require('./rabitMQ-Publish.js')
const { buildCAClient, registerAndEnrollUser, enrollAdmin,enrollAdmin2,buildStaticCAClient } = require('./CAUtil.js');
const { buildCCPOrg1, buildWallet } = require('./AppUtil.js');
//AC
const {stringify, parse } = require('flatted');

const channelName = 'mychannel';
// you have to change 'meatsale' to the name of the chaincodeName in the package.json property name e.g., name:'meatsale', name:'vaccine', etc
const chaincodeName = 'meatsale';
const mspOrg1 = 'Org1MSP';
const walletPath = path.join(__dirname, 'wallet');
const Org1UserId = 'buyer_Buyer';
const attributeValue = {name: 'regulator', type: 'Regulator'} // buyer. seller

//const chaincodeName = 'triggerPaidLate';

const org1 = 'Org1MSP';

const RED = '\x1b[31m\n';
const GREEN = '\x1b[32m\n';
const BLUE = '\x1b[34m';
const RESET = '\x1b[0m';

    

	let parametersObject = {
		"buyerP": { "warehouse": "70 Glouxter", "name": "buyer name",  "org": "Canada Import Inc", "dept": "finance"},
		"sellerP": { "returnAddress": "51 Riduea", "name": "seller name",  "org": "Argentina Export Inc", "dept": "finance"},
		"transportCoP": { "returnAddress": "60 Orleans", "name": "transportCo name"},
		"assessorP": { "returnAddress": "11 copper", "name": "assessor name"},
		"regulatorP":{"name": "Hassan", "org": "Canada Import Inc", "dept": "finance"},
		"storageP":{"address": "55 Riduea"},
		"shipperP": {"name": "shipper name"},
		"adminP":{"name": "admin",  "org": "org1", "dept": "finance"},
		"barcodeP":{},
		"qnt": 2,
		"qlt": 3,
		"amt": 3, 
		"curr": 1,
		"payDueDate": "2024-10-28T17:49:41.422Z", //"2025-10-28T17:49:41.422Z" fulfillment
		"delAdd": "delAdd",
		"effDate": "2026-08-28T17:49:41.422Z", //"2025-08-28T17:49:41.422Z"
		"delDueDateDays": 3,
		"interestRate": 2
	  }
  let parameters = JSON.stringify(parametersObject)


// Build a static instance of the fabric ca services client
// const caOrg1Client = buildStaticCAClient(staticCAURL, staticCATLSCert, 'ca.org1.example.com');


/**
 * Perform a sleep -- asynchronous wait
 * @param ms the time in milliseconds to sleep for
 */
function sleep(ms) {
	return new Promise((resolve) => setTimeout(resolve, ms));
}

async function initGatewayForOrg1(useCommitEvents) {
	console.log(`${GREEN}--> Fabric client user & Gateway init: Using Org1 identity to Org1 Peer${RESET}`);
	// build an in memory object with the network configuration (also known as a connection profile)
	const ccpOrg1 = buildCCPOrg1();



	try {
		// Create a new gateway for connecting to Org's peer node.
		const gatewayOrg1 = new Gateway();

		// Specify the path to the wallet containing the certificates generated by cryptogen
		// setup the wallet to cache the credentials of the application user, on the app server locally
		const walletPathOrg1 = path.join(__dirname, 'wallet');
		const walletOrg1 = await buildWallet(Wallets, walletPathOrg1);
		if (useCommitEvents) {
			await gatewayOrg1.connect(ccpOrg1, {
				wallet: walletOrg1,
				identity: Org1UserId,
				discovery: { enabled: true, asLocalhost: true }
			});
		} else {
			await gatewayOrg1.connect(ccpOrg1, {
				wallet: walletOrg1,
				identity: Org1UserId,
				discovery: { enabled: true, asLocalhost: true },
				eventHandlerOptions: EventStrategies.NONE
			});
		}


		return gatewayOrg1;
	} catch (error) {
		console.error(`Error in connecting to gateway for Org1: ${error}`);
		process.exit(1);
	}
}

async function meatSale() {
	console.log(`${BLUE} **** START ****${RESET}`);
	try {
		/** ******* Fabric client init: Using Org1 identity to Org1 Peer ******* */
		const gateway1Org1 = await initGatewayForOrg1(true); // transaction handling uses commit events

		try {
			//
			//  - - - - - -  C H A I N C O D E  E V E N T S
			//
			console.log(`${BLUE} **** CHAINCODE EVENTS ****${RESET}`);
			let transaction;
			let listener;
			const network1Org1 = await gateway1Org1.getNetwork(channelName);
			const contract1Org1 = network1Org1.getContract(chaincodeName);
      
			try {
				// first create a listener to be notified of chaincode code events
				// coming from the chaincode ID "events"
				listener = async (event) => {
					// console.log("evnets....... ", event)
					// The payload of the chaincode event is the value place there by the
					// chaincode. Notice it is a byte data and the application will have
					// to know how to deserialize.
					// In this case we know that the chaincode will always place the asset
					// being worked with as the payload for all events produced.
					const asset = JSON.parse(event.payload.toString());
				    console.log("asset....... ", asset , typeof asset)
					console.log(`${GREEN}<-- Contract Event Received: ${event.eventName} - ${JSON.stringify(asset)}${RESET}`);
					// show the information available with the event
					console.log(`*** Event: ${event.eventName}:${asset.contractId}`);
					// notice how we have access to the transaction information that produced this chaincode event
					const eventTransaction = event.getTransactionEvent();
					console.log(`*** transaction: ${eventTransaction.transactionId} status:${eventTransaction.status}`);

					// notice how we have access to the full block that contains this transaction
					const eventBlock = eventTransaction.getBlockEvent();
					console.log(`*** block: ${eventBlock.blockNumber.toString()}`);

                    // let assetObject = {};
					// assetObject.chaincodeName = chaincodeName;
					// assetObject.eventName = event.eventName;
					// assetObject.blockNumber = eventBlock.blockNumber.toString();
					// assetObject.asset = asset;

					// let existingContent = [];
					// let fileContent = fs.readFileSync('meatsale-events.json', 'utf-8');
					// if(fileContent){
					// 	existingContent = JSON.parse(fileContent);
					// }
					// existingContent.push(assetObject);
					// fs.writeFileSync('meatsale-events.json', JSON.stringify(existingContent, null, 2), 'utf-8');

					// console.log(`${GREEN}<-- Start publishing Event: ${event.eventName} - ${JSON.stringify(asset)}${RESET}`);
					// publish(JSON.stringify(assetObject))
				};
				// now start the client side event service and register the listener
				console.log(`${GREEN}--> Start contract event stream to peer in Org1${RESET}`);
				await contract1Org1.addContractListener(listener);
			} catch (eventError) {
				console.log(`${RED}<-- Failed: Setup contract events - ${eventError}${RESET}`);
			}
            let InitRes = null;
			try {
				// C R E A T E
                
				console.log(`--> Submit Transaction: init`);
				transaction = contract1Org1.createTransaction('init');
				console.log(`--> after init`);
				InitRes = await transaction.submit(parameters);
				console.log(`--> after sumbit parameter`);
				InitRes = JSON.parse(InitRes.toString()); //JSON.parse
				console.log(`--> after stringify`);
			} catch (createError) {
				console.log(`${RED}<-- Submit Failed: init - ${createError}${RESET}`);
				return
			}
			//
			try{
				transaction = contract1Org1.createTransaction('trigger_paid');
				console.log(`--> after createTransaction trigger_paid`);
				let response = await transaction.submit(JSON.stringify({ contractId: InitRes.contractId, event: {} }))
				console.log(`--> after submit`);	
				console.log(response);
				response = JSON.parse(response.toString())
				console.log(`--> after response`);	
				console.log(response);	
				if(!response.successful){
					console.log(`${RED}<--- access controll error: ${response.message}${RESET}`)
					process.exit(1);
					return ;
				}
				console.log(`<-- Submit InIt Result: ${InitRes.contractId}${RESET}`);
				console.log(`<-- Submit trigger_paid Result: ${response.successful}${RESET}`);
			}catch(createError){
				console.log(`${RED}<-- Submit Failed: trigger_paid - ${createError}${RESET}`);
			}

				try{
				console.log("chaincodeId: ", InitRes.contractId)
				transaction = contract1Org1.createTransaction('violateObligation_payment');
				console.log(`--> after createTransaction of violateObligation_payment`);
				let response = await transaction.submit(InitRes.contractId);
				console.log(`--> after submit`);
				console.log(response);
				response = JSON.parse(response.toString())
				console.log(`--> after response`);	
				console.log(response);			
			}catch(createError){
				console.log(`${RED}<-- Submit Failed: violateObligation_payment - ${createError}${RESET}`);
				return
			}
			//Test ACpolicy 
			/*
			try{
				transaction = contract1Org1.createTransaction('storeRolesPolicy');
				console.log(`--> after createTransaction storePolicy`);
				//let response = await transaction.submit(JSON.stringify({ contractId: InitRes.contractId}))
				let response = await transaction.submit(InitRes.contractId);
				console.log(`--> after submit`);	
				console.log(response);
				response = JSON.parse(response.toString())
				console.log(`--> after response`);	
				console.log(response);	
				if(!response.successful){
					console.log(`${RED}<--- access controll error: ${response.message}${RESET}`)
					process.exit(1);
					return ;
				}
				console.log(`<-- Submit InIt Result: ${InitRes.contractId}${RESET}`);
				console.log(`<-- Submit storePolicy Result: ${response.successful}${RESET}`);
			}catch(createError){
				console.log(`${RED}<-- Submit Failed: storePolicy - ${createError}${RESET}`);
			}*/
			//get ACPolicy 
            /*
			try {
				transaction = contract1Org1.createTransaction('getRolePolicy');
				console.log(`--> Calling getPolicy for contractId: ${InitRes.contractId}`);
				
				// Use evaluateTransaction for read-only queries
				const responseBytes = await transaction.evaluate(InitRes.contractId);
				console.log(`--> Transaction evaluated.`);

				let response;
				try {
					response = JSON.parse(responseBytes.toString());
				} catch (parseError) {
					console.error(`${RED}<-- Failed to parse getPolicy response: ${parseError}${RESET}`);
					process.exit(1);
					return;
				}

				if (!response.successful) {
					console.log(`${RED}<--- Access denied: ${response.message}${RESET}`);
					process.exit(1);
					return;
				}

				console.log(`<-- âœ… getPolicy Success for Contract ${InitRes.contractId}`);
				console.log(`<-- ðŸ“Œ Policy Hash: ${response.policyRecord.hash}`);
				console.log(`<-- ðŸ‘¥ Roles: ${JSON.stringify(response.policyRecord.policy.roles, null, 2)}`);

			} catch (createError) {
				console.log(`${RED}<-- âŒ Failed to evaluate getPolicy - ${createError}${RESET}`);
				process.exit(1);
			}*/
			// all done with this listener
			contract1Org1.removeContractListener(listener);

		} catch (runError) {
			console.error(`Error in transaction: ${runError}`);
			if (runError.stack) {
				console.error(runError.stack);
			}
		}
	} catch (error) {
		console.error(`Error in setup: ${error}`);
		if (error.stack) {
			console.error(error.stack);
		}
		process.exit(1);
	}

	await sleep(5000);
	console.log(`${BLUE} **** END ****${RESET}`);
	process.exit(0);
}
 meatSale();


// build an in memory object with the network configuration (also known as a connection profile)
const ccp = buildCCPOrg1();
// build an instance of the fabric ca services client based on
// the information in the network configuration
const caClient = buildCAClient(FabricCAServices, ccp, 'ca.org1.example.com');

async function appEnrollAdmin(){
    const wallet = await buildWallet(Wallets, walletPath);
    // in a real application this would be done on an administrative flow, and only once
    await enrollAdmin(caClient, wallet, mspOrg1);
}

async function appRegisterAndEnrollUser(){
    const wallet = await buildWallet(Wallets, walletPath);
    // in a real application this would be done only when a new user was required to be added
    // and would be part of an administrative flow
    await registerAndEnrollUser(caClient, wallet, mspOrg1, Org1UserId, 'org1.department1',attributeValue);

}


//appEnrollAdmin()
//appRegisterAndEnrollUser()



